<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aweSOM.som &mdash; aweSOM 1.4.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=350a9c04"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            aweSOM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faqs.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">aweSOM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">aweSOM.som</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aweSOM.som</h1><div class="highlight"><pre>
<span></span><span class="c1">## Self-Organizing Map base code including training and fitting data,</span>
<span class="c1">## along with limited cluster plotting capabilities, ported from</span>
<span class="c1">## the POPSOM library by Li Yuan (2018) https://github.com/njali2001/popsom.git</span>
<span class="c1">## with modifications by Trung Ha (2024) for aweSOM</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;font.size&quot;</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">euclidean_distances</span>

<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>

<span class="n">seed</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>


<div class="viewcode-block" id="Lattice">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice">[docs]</a>
<span class="k">class</span> <span class="nc">Lattice</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xdim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">ydim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">alpha_0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">train</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">alpha_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;decay&quot;</span><span class="p">,</span>
        <span class="n">sampling_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sampling&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the SOM lattice.</span>

<span class="sd">        Args:</span>
<span class="sd">                xdim (int): The x dimension of the map. Default is 10.</span>
<span class="sd">                ydim (int): The y dimension of the map. Default is 10.</span>
<span class="sd">                alpha_0 (float): The initial learning rate, should be a positive non-zero real number. Default is 0.3.</span>
<span class="sd">                train (int): Number of total training iterations; include for all batches. Default is 1000.</span>
<span class="sd">                alpha_type (str): A string that determines whether the learning rate is static or decaying. Default is &quot;decay&quot;.</span>
<span class="sd">                sampling_type (str): A string that determines whether the initial lattice is uniform or randomly sampled from the data. Default is &quot;sampling&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span> <span class="o">=</span> <span class="n">xdim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span> <span class="o">=</span> <span class="n">ydim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train</span> <span class="o">=</span> <span class="n">train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">sampling_type</span>  <span class="c1"># uniform or random sampling initial lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">alpha_type</span> <span class="o">==</span> <span class="s2">&quot;static&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_type</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">=</span> <span class="n">alpha_0</span>
        <span class="k">elif</span> <span class="n">alpha_type</span> <span class="o">==</span> <span class="s2">&quot;decay&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_type</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">=</span> <span class="n">alpha_0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;alpha_type must be either &#39;static&#39; or &#39;decay&#39;&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_frequency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span> <span class="o">//</span> <span class="mi">200</span>  <span class="c1"># how often to save the node weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umat_history</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="Lattice.train_lattice">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.train_lattice">[docs]</a>
    <span class="k">def</span> <span class="nf">train_lattice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">features_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">number_of_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">save_lattice</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">restart_lattice</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Train the Model with numba JIT acceleration.</span>

<span class="sd">        Args:</span>
<span class="sd">                data (np.ndarray): A numpy 2D array where each row contains an unlabeled training instance.</span>
<span class="sd">                features_names (list[str]): A list of feature names.</span>
<span class="sd">                labels (np.ndarray, optional): A vector with one label (ground truth) for each observation in data. Defaults to None.</span>
<span class="sd">                number_of_steps (int): Number of steps taken this batch, used for keeping track of training restarts. Default is self.train.</span>
<span class="sd">                save_lattice (bool, optional): A flag that determines whether the node weights are saved to a file at the end of training. Defaults to False.</span>
<span class="sd">                restart_lattice (np.ndarray, optional): Vectors for the weights of the nodes from past realizations. Defaults to None.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">restart_lattice</span> <span class="o">=</span> <span class="n">restart_lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_lattice</span> <span class="o">=</span> <span class="n">save_lattice</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features_names</span> <span class="o">=</span> <span class="n">features_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">if</span> <span class="n">number_of_steps</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this_batch_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this_batch_train</span> <span class="o">=</span> <span class="n">number_of_steps</span>
        <span class="c1"># self.momentum_decay_rate = momentum_decay_rate</span>

        <span class="c1"># check if the dims are reasonable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;build: map is too small.&quot;</span><span class="p">)</span>

        <span class="c1"># train SOM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fast_som</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lattice.fast_som">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.fast_som">[docs]</a>
    <span class="k">def</span> <span class="nf">fast_som</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs the self-organizing map (SOM) training.</span>

<span class="sd">        This method initializes the SOM with random values or a subset of the data, and then trains the SOM by updating the</span>
<span class="sd">        node weights based on the input vectors. The training process includes adjusting the learning rate, shrinking the</span>
<span class="sd">        neighborhood size, and saving the node weights and U-matrix periodically.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># some constants</span>
        <span class="n">number_input_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">number_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">number_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span>
        <span class="n">this_batch_train</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this_batch_train</span>
        <span class="p">)</span>  <span class="c1"># only train for this number of steps; useful for restarting training</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">restart_lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">restart_lattice</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                <span class="c1"># vector with small init values for all nodes</span>
                <span class="c1"># NOTE: each row represents a node, each column represents a feature.</span>
                <span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">number_nodes</span><span class="p">,</span> <span class="n">number_features</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># sample a random subset of the data to initialize the lattice</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">number_input_vectors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">number_nodes</span><span class="p">)</span>
                <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>  <span class="c1"># save the initial lattice</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">umat_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_umat</span><span class="p">())</span>  <span class="c1"># save the initial U-matrix</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>  <span class="c1"># starting learning rate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">alpha_freq</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train</span> <span class="o">//</span> <span class="mi">25</span>
            <span class="p">)</span>  <span class="c1"># how often to decay the learning rate; at 24 steps, alpha_f ~ 1e-3 alpha_0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha_freq</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># compute the initial neighborhood size and step</span>
        <span class="n">nsize_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xdim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nsize_min</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">nsize_step</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">this_batch_train</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="p">)</span>  <span class="c1"># for the third quarter of the training steps, shrink the neighborhood</span>
        <span class="n">nsize_freq</span> <span class="o">=</span> <span class="n">nsize_step</span> <span class="o">//</span> <span class="p">(</span>
            <span class="n">nsize_max</span> <span class="o">-</span> <span class="n">nsize_min</span>
        <span class="p">)</span>  <span class="c1"># how often to shrink the neighborhood</span>

        <span class="c1"># if self.epoch &lt; 2 * nsize_step:</span>
        <span class="c1"># 	nsize = nsize_max</span>
        <span class="c1"># elif self.epoch &gt;= 3 * nsize_step:</span>
        <span class="c1"># 	nsize = nsize_min</span>
        <span class="c1"># else:</span>
        <span class="c1"># 	nsize = nsize_max - self.epoch // nsize_freq</span>
        <span class="n">nsize</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">nsize_max</span>  <span class="c1"># start with the largest neighborhood size at each training batch</span>
        <span class="p">)</span>

        <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span>  <span class="c1"># counts the number of epochs per nsize_freq</span>
        <span class="n">stop_epoch</span> <span class="o">=</span> <span class="n">epoch</span> <span class="o">+</span> <span class="n">this_batch_train</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;starting epoch is: &quot;</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;stopping epoch is: &quot;</span><span class="p">,</span> <span class="n">stop_epoch</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving lattice every &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_frequency</span><span class="p">,</span> <span class="s2">&quot; epochs&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># constants for the Gamma function</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">number_nodes</span><span class="p">)),</span> <span class="p">(</span><span class="n">number_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># a vector with all node 1D addresses</span>

        <span class="c1"># x-y coordinate of ith node: m2Ds[i,] = c(xi, yi)</span>
        <span class="n">m2Ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span><span class="p">)</span>

        <span class="c1"># this ensures that the same random order is not repeated if the training is restarted</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Added 06/17/2024: use random number generator, shuffle the data and take the first train samples</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">number_input_vectors</span><span class="p">)</span>
        <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># Added 06/25/2024: if the number of training steps is larger than the number of data points, repeat the shuffled indices</span>
        <span class="k">if</span> <span class="n">this_batch_train</span> <span class="o">&gt;</span> <span class="n">number_input_vectors</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">this_batch_train</span> <span class="o">//</span> <span class="n">number_input_vectors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">xk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">[</span><span class="n">indices</span><span class="p">[:</span><span class="n">this_batch_train</span><span class="p">],</span> <span class="p">:]</span>

        <span class="c1"># implement momentum-based gradient descent</span>
        <span class="c1"># momentum_decay_rate = self.momentum_decay_rate</span>

        <span class="c1"># history of the loss function</span>
        <span class="c1"># loss_freq = 1000</span>
        <span class="c1"># self.loss_history = np.zeros((self.train, number_features))</span>
        <span class="c1"># self.average_loss = np.zeros((self.train//loss_freq, number_features))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Begin training&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Evaluating epoch = &quot;</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># if (epoch % loss_freq == 0) &amp; (epoch != 0):</span>
            <span class="c1"># 	this_average_loss = np.mean(self.loss_history[epoch-loss_freq:epoch], axis=0) # average loss over the last [loss_freq] epochs</span>
            <span class="c1"># 	self.average_loss[epoch//loss_freq-1,:] = this_average_loss</span>

            <span class="c1"># if training step has gone over the step limit, terminate</span>
            <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;=</span> <span class="n">stop_epoch</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Terminating from step limit reached at epoch &quot;</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="n">epoch</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_lattice</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving final lattice&quot;</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;lattice_</span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">xdim</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">ydim</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="si">}</span><span class="s2">.npy&quot;</span><span class="p">,</span>
                        <span class="n">lattice</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">break</span>

                <span class="c1"># get one random input vector</span>
            <span class="n">xk_m</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="n">epoch</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># calculate the relative distance between input vector and nodes, take the closest node as the BMU</span>
            <span class="c1"># momentum = diff * momentum_decay_rate # momentum-based gradient descent</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">lattice</span> <span class="o">-</span> <span class="n">xk_m</span>
            <span class="n">squ</span> <span class="o">=</span> <span class="n">diff</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">squ</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="c1"># self.loss_history[epoch,:] = np.sqrt(s[c])</span>

            <span class="c1"># update step</span>
            <span class="n">gamma_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gamma</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m2Ds</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nsize</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">number_features</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># lattice -= (diff + momentum) * gamma_m</span>
            <span class="n">lattice</span> <span class="o">-=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">gamma_m</span>

            <span class="c1"># shrink the neighborhood size every [nsize_freq] epochs</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">epoch</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nsize_step</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">epoch</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">)</span> <span class="o">%</span> <span class="n">nsize_freq</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">nsize</span> <span class="o">&gt;</span> <span class="n">nsize_min</span>
            <span class="p">):</span>
                <span class="n">nsize</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">nsize_max</span> <span class="o">-</span> <span class="p">((</span><span class="n">epoch</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nsize_step</span><span class="p">)</span> <span class="o">//</span> <span class="n">nsize_freq</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Shrinking neighborhood size to </span><span class="si">{</span><span class="n">nsize</span><span class="si">}</span><span class="s2"> at epoch </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># decay the learning rate every [alpha_freq] epochs</span>
            <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="n">alpha_freq</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">epoch</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">*=</span> <span class="mf">0.75</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decaying learning rate to </span><span class="si">{</span><span class="n">alpha</span><span class="si">}</span><span class="s2"> at epoch </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># save lattice sparingly</span>
            <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_frequency</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># print(&quot;Saving lattice at epoch &quot;, epoch, flush=True)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>

                <span class="c1"># compute the umatrix and save it</span>
                <span class="n">umat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_umat</span><span class="p">()</span>
                <span class="c1"># np.save(f&quot;umat_{epoch}_{self.xdim}{self.ydim}_{self.alpha}_{self.train}.npy&quot;, umat)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umat_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">umat</span><span class="p">)</span>

            <span class="n">epoch</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Training complete&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># update the learning rate, lattice, and Umatrix after training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_umat</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">lattice</span>  <span class="c1"># lattice takes the shape of [X*Y, F]</span></div>


<div class="viewcode-block" id="Lattice.Gamma">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.Gamma">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">Gamma</span><span class="p">(</span>
        <span class="n">index_bmu</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">m2Ds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">nsize</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">gaussian</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the neighborhood function for a given BMU on a lattice.</span>

<span class="sd">        Args:</span>
<span class="sd">                index_bmu (int): The index of the BMU node on the lattice.</span>
<span class="sd">                m2Ds (np.ndarray): Lattice coordinate of each node.</span>
<span class="sd">                alpha (float): The amplitude parameter for the Gaussian function, AKA the learning rate.</span>
<span class="sd">                nsize (int): The size of the neighborhood.</span>
<span class="sd">                gaussian (bool, optional): Whether to use Gaussian function or not. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">                np.ndarray: The neighborhood function values for each node on the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dist_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">m2Ds</span><span class="p">[</span><span class="n">index_bmu</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">m2Ds</span>
        <span class="p">)</span>  <span class="c1"># 2d distance between the BMU and the rest of the lattice</span>
        <span class="n">chebyshev_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">dist_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># initialize the Chebyshev distance array</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span>
            <span class="n">dist_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>  <span class="c1"># numba max does not have axis argument, otherwise this would be chebyshev_dist = np.max(dist_2d, axis=1)</span>
            <span class="n">chebyshev_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Define the Gaussian function to calculate the neighborhood function</span>
        <span class="k">def</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;gauss -- Gaussian function&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">dist</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># if a node on the lattice is in within nsize neighborhood, then h = Gaussian(alpha), else h = 0.0</span>
        <span class="k">if</span> <span class="n">gaussian</span><span class="p">:</span>  <span class="c1"># use Gaussian function</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span><span class="n">chebyshev_dist</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">nsize</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise everything within nsize is multiplied by alpha, and everything outside is unchanged</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">chebyshev_dist</span> <span class="o">&lt;=</span> <span class="n">nsize</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="n">h</span><span class="p">[</span><span class="n">chebyshev_dist</span> <span class="o">&gt;</span> <span class="n">nsize</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">0.0</span>  <span class="c1"># manually set the values outside the neighborhood to 0</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">h</span></div>


<div class="viewcode-block" id="Lattice.map_data_to_lattice">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.map_data_to_lattice">[docs]</a>
    <span class="k">def</span> <span class="nf">map_data_to_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        After training, map each data point to the nearest node in the lattice.</span>

<span class="sd">        Returns:</span>
<span class="sd">                np.ndarray[int]: A 2D array with the x and y coordinates of the best matching nodes for each data point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Begin matching points with nodes&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data_to_lattice_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">projection_1d</span> <span class="o">=</span> <span class="n">data_to_lattice_1d</span>

        <span class="n">projection_1d_to_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">projection_1d</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection_1d</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># make it a 2D array</span>

        <span class="n">projection_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span><span class="n">projection_1d_to_2d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projection_2d</span> <span class="o">=</span> <span class="n">projection_2d</span>

        <span class="k">return</span> <span class="n">projection_2d</span></div>


<div class="viewcode-block" id="Lattice.assign_cluster_to_lattice">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.assign_cluster_to_lattice">[docs]</a>
    <span class="k">def</span> <span class="nf">assign_cluster_to_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">merge_cost</span><span class="o">=</span><span class="mf">0.005</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns clusters to the lattice based on the computed centroids.</span>

<span class="sd">        Args:</span>
<span class="sd">                smoothing (float, optional): Smoothing parameter for computing Umatrix. Defaults to None.</span>
<span class="sd">                merge_cost (float, optional): Cost threshold for merging similar centroids. Defaults to 0.005.</span>

<span class="sd">        Returns:</span>
<span class="sd">                numpy.ndarray: Array representing the assigned clusters for each lattice point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">smoothing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># smooth the Umatrix before computing the centroids</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">umat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_umat</span><span class="p">(</span><span class="n">smoothing</span><span class="p">)</span>
        <span class="n">naive_centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_centroids</span><span class="p">(</span>
            <span class="kc">False</span>
        <span class="p">)</span>  <span class="c1"># all local minima are centroids</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_similar_centroids</span><span class="p">(</span>
            <span class="n">naive_centroids</span><span class="p">,</span> <span class="n">merge_cost</span>
        <span class="p">)</span>  <span class="c1"># merge similar centroids</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span>
        <span class="n">centr_locs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># create list of centroid locations</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="n">cx</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                <span class="n">cy</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_y&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>

                <span class="n">centr_locs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">))</span>

        <span class="n">unique_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">centr_locs</span><span class="p">))</span>
        <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_ids</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of clusters : </span><span class="si">{</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Centroids: &quot;</span><span class="p">,</span> <span class="n">unique_ids</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># mapping = {}</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="c1"># mapping[i] = unique_ids[i]</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">],</span>
                        <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_y&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">],</span>
                    <span class="p">)</span> <span class="o">==</span> <span class="n">unique_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">clusters</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_assigned_clusters</span> <span class="o">=</span> <span class="n">clusters</span>
        <span class="k">return</span> <span class="n">clusters</span></div>


<div class="viewcode-block" id="Lattice.assign_cluster_to_data">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.assign_cluster_to_data">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">assign_cluster_to_data</span><span class="p">(</span>
        <span class="n">projection_2d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">clusters_on_lattice</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a lattice and cluster assignments on that lattice, return the cluster ids of the data (in a 1d array)</span>

<span class="sd">        Args:</span>
<span class="sd">                projection_2d (np.ndarray): 2d array with x-y coordinates of the node associated with each data point</span>
<span class="sd">                clusters_on_lattice (np.ndarray): X x Y matrix of cluster labels on lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">                np.ndarray: cluster_id of each data point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cluster_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">projection_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">projection_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">cluster_id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clusters_on_lattice</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">projection_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">projection_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">cluster_id</span></div>


<div class="viewcode-block" id="Lattice.best_match">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.best_match">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">best_match</span><span class="p">(</span><span class="n">lattice</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">obs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given input vector inp[n,f] (where n is number of different observations, f is number of features per observation), return the best matching node.</span>

<span class="sd">        Args:</span>
<span class="sd">                lattice (np.ndarray): weight values of the lattice</span>
<span class="sd">                obs (np.ndarray): observations (input vectors)</span>
<span class="sd">                full (bool, optional): indicate whether to return first and second best match. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">                np.ndarray: return the 1d index of the best-matched node (within the lattice) for each observation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="n">best_match_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">best_match_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">lattice</span> <span class="o">-</span> <span class="n">obs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">squ</span> <span class="o">=</span> <span class="n">diff</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">squ</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
                <span class="c1"># numba does not support argsort, so we record the top two best matches this way</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">best_match_node</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
                <span class="n">s</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">best_match_node</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">best_match_node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;i = &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">best_match_node</span></div>


<div class="viewcode-block" id="Lattice.coordinate">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.coordinate">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">coordinate</span><span class="p">(</span><span class="n">rowix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xdim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from a list of row index to an array of xy-coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">                rowix (np.ndarray): 1d array with the 1d indices of the points of interest (n x 1 matrix)</span>
<span class="sd">                xdim (int): x dimension of the lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">                np.ndarray: array with x and y coordinates of each point in rowix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">len_rowix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rowix</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">len_rowix</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">len_rowix</span><span class="p">):</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rowix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">xdim</span><span class="p">,</span> <span class="n">rowix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">xdim</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">coords</span></div>


<div class="viewcode-block" id="Lattice.rowix">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.rowix">[docs]</a>
    <span class="k">def</span> <span class="nf">rowix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from a xy-coordinate to a row index.</span>

<span class="sd">        Args:</span>
<span class="sd">                x (int): The x-coordinate of the map.</span>
<span class="sd">                y (int): The y-coordinate of the map.</span>

<span class="sd">        Returns:</span>
<span class="sd">                int: The row index corresponding to the given xy-coordinate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rix</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
        <span class="k">return</span> <span class="n">rix</span></div>


<div class="viewcode-block" id="Lattice.node_weight">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.node_weight">[docs]</a>
    <span class="k">def</span> <span class="nf">node_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the weight values of a node at (x,y) on the lattice.</span>

<span class="sd">        Args:</span>
<span class="sd">                x (int): x-coordinate of the node.</span>
<span class="sd">                y (int): y-coordinate of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">                np.ndarray: 1d array of weight values of said node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rowix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span></div>


<div class="viewcode-block" id="Lattice.compute_centroids">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.compute_centroids">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">explicit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the centroid for each node in the lattice given a precomputed Umatrix.</span>

<span class="sd">        Args:</span>
<span class="sd">                explicit (bool): Controls the shape of the connected component.</span>

<span class="sd">        Returns:</span>
<span class="sd">                dict: A dictionary containing the matrices with the same x-y dimensions as the original map,</span>
<span class="sd">                containing the centroid x-y coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
        <span class="n">ydim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span>
        <span class="n">heat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umat</span>
        <span class="n">centroid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ydim</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xdim</span><span class="p">)])</span>
        <span class="n">centroid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ydim</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xdim</span><span class="p">)])</span>

        <span class="k">def</span> <span class="nf">find_this_centroid</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">):</span>
            <span class="c1"># recursive function to find the centroid of a point on the map</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">centroid_x</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">centroid_y</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;bestx&quot;</span><span class="p">:</span> <span class="n">centroid_x</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">],</span> <span class="s2">&quot;besty&quot;</span><span class="p">:</span> <span class="n">centroid_y</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]}</span>

            <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
            <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
            <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

            <span class="c1"># (ix, iy) is an inner map element</span>
            <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">xdim</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">ydim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

            <span class="c1"># (ix, iy) is bottom left corner</span>
            <span class="k">elif</span> <span class="n">ix</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># (ix, iy) is bottom right corner</span>
            <span class="k">elif</span> <span class="n">ix</span> <span class="o">==</span> <span class="n">xdim</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

            <span class="c1"># (ix, iy) is top right corner</span>
            <span class="k">elif</span> <span class="n">ix</span> <span class="o">==</span> <span class="n">xdim</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">==</span> <span class="n">ydim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

            <span class="c1"># (ix, iy) is top left corner</span>
            <span class="k">elif</span> <span class="n">ix</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">==</span> <span class="n">ydim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

            <span class="c1"># (ix, iy) is a left side element</span>
            <span class="k">elif</span> <span class="n">ix</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">ydim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># (ix, iy) is a bottom side element</span>
            <span class="k">elif</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">xdim</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

            <span class="c1"># (ix, iy) is a right side element</span>
            <span class="k">elif</span> <span class="n">ix</span> <span class="o">==</span> <span class="n">xdim</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">&lt;</span> <span class="n">ydim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

            <span class="c1"># (ix, iy) is a top side element</span>
            <span class="k">elif</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">xdim</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iy</span> <span class="o">==</span> <span class="n">ydim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

                <span class="k">if</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">heat</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">min_y</span> <span class="o">=</span> <span class="n">iy</span>

                    <span class="c1"># if successful</span>
                    <span class="c1"># move to the square with the smaller value, i_e_, call</span>
                    <span class="c1"># find_this_centroid on this new square</span>
                    <span class="c1"># note the RETURNED x-y coords in the centroid_x and</span>
                    <span class="c1"># centroid_y matrix at the current location</span>
                    <span class="c1"># return the RETURNED x-y coordinates</span>

            <span class="k">if</span> <span class="n">min_x</span> <span class="o">!=</span> <span class="n">ix</span> <span class="ow">or</span> <span class="n">min_y</span> <span class="o">!=</span> <span class="n">iy</span><span class="p">:</span>
                <span class="n">r_val</span> <span class="o">=</span> <span class="n">find_this_centroid</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">)</span>

                <span class="c1"># if explicit is set show the exact connected component</span>
                <span class="c1"># otherwise construct a connected componenent where all</span>
                <span class="c1"># nodes are connected to a centrol node</span>
                <span class="k">if</span> <span class="n">explicit</span><span class="p">:</span>

                    <span class="n">centroid_x</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_x</span>
                    <span class="n">centroid_y</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_y</span>
                    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;bestx&quot;</span><span class="p">:</span> <span class="n">min_x</span><span class="p">,</span> <span class="s2">&quot;besty&quot;</span><span class="p">:</span> <span class="n">min_y</span><span class="p">}</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">centroid_x</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_val</span><span class="p">[</span><span class="s2">&quot;bestx&quot;</span><span class="p">]</span>
                    <span class="n">centroid_y</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_val</span><span class="p">[</span><span class="s2">&quot;besty&quot;</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">r_val</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">centroid_x</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">ix</span>
                <span class="n">centroid_y</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">iy</span>
                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;bestx&quot;</span><span class="p">:</span> <span class="n">ix</span><span class="p">,</span> <span class="s2">&quot;besty&quot;</span><span class="p">:</span> <span class="n">iy</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xdim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ydim</span><span class="p">):</span>
                <span class="n">find_this_centroid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">:</span> <span class="n">centroid_x</span><span class="p">,</span> <span class="s2">&quot;centroid_y&quot;</span><span class="p">:</span> <span class="n">centroid_y</span><span class="p">}</span></div>


<div class="viewcode-block" id="Lattice.replace_value">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.replace_value">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="c1"># @njit(parallel=True) # numba does not support dictionary; so cannot parallelize this function</span>
    <span class="k">def</span> <span class="nf">replace_value</span><span class="p">(</span>
        <span class="n">centroids</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">centroid_a</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">centroid_b</span><span class="p">:</span> <span class="nb">tuple</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces the values of centroid_a with the values of centroid_b in the given centroids dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">                centroids (dict[str, np.ndarray]): A dictionary containing the centroids.</span>
<span class="sd">                centroid_a (tuple): The coordinates of the centroid to be replaced.</span>
<span class="sd">                centroid_b (tuple): The coordinates of the centroid to replace with.</span>

<span class="sd">        Returns:</span>
<span class="sd">                dict[str, np.ndarray]: The updated centroids dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">xdim</span><span class="p">,</span> <span class="n">ydim</span><span class="p">)</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xdim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ydim</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">==</span> <span class="n">centroid_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_y&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">==</span> <span class="n">centroid_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">centroid_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_y&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">centroid_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">centroids</span></div>


<div class="viewcode-block" id="Lattice.merge_similar_centroids">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.merge_similar_centroids">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_similar_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">naive_centroids</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge centroids that are close enough together.</span>

<span class="sd">        Args:</span>
<span class="sd">                naive_centroids (np.ndarray): original centroids before merging</span>
<span class="sd">                threshold (float, optional): Any centroids with pairwise cost less than this threshold is merged. Defaults to 0.3.</span>

<span class="sd">        Returns:</span>
<span class="sd">                np.ndarray: new node map with combined centroids</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">heat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umat</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">naive_centroids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">unique_centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_centroids</span><span class="p">(</span>
            <span class="n">centroids</span>
        <span class="p">)</span>  <span class="c1"># the nodes_count dictionary is also created here, so don&#39;t remove this line</span>

        <span class="c1"># for each pair of centroids, compute the weighted distance between them via interpolating the umat</span>
        <span class="c1"># if the distance is less than the threshold, combine the centroids</span>

        <span class="n">cost_between_centroids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">])):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_y&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                    <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_y&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="n">num_sample</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_sample</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_sample</span>
                <span class="p">)</span>
                <span class="n">umat_dist</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">heat</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
                <span class="n">total_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">umat_dist</span><span class="p">)</span>
                <span class="c1"># total_cost /= num_sample</span>
                <span class="n">cost_between_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">total_cost</span><span class="p">])</span>

        <span class="c1"># cost_between_centroids.sort(key=lambda x: x[2])</span>
        <span class="n">sorted_cost</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">cost_between_centroids</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># this ranks all pairwise cost in ascending order</span>
        <span class="c1"># normalize the cost such that the largest cost at each step is always one</span>
        <span class="n">sorted_cost</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">/</span> <span class="n">sorted_cost</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sorted_cost</span><span class="p">]</span>

        <span class="c1"># combine the centroids recursively until the threshold is reached</span>
        <span class="k">if</span> <span class="n">sorted_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">centroid_a</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sorted_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">centroid_b</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sorted_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># heat_a = heat[centroid_a[0], centroid_a[1]]</span>
            <span class="c1"># heat_b = heat[centroid_b[0], centroid_b[1]]</span>
            <span class="n">nodes_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_count</span><span class="p">[</span><span class="n">centroid_a</span><span class="p">]</span>
            <span class="n">nodes_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_count</span><span class="p">[</span><span class="n">centroid_b</span><span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Centroid A: </span><span class="si">{</span><span class="n">centroid_a</span><span class="si">}</span><span class="s2">, count: </span><span class="si">{</span><span class="n">nodes_a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Centroid B: </span><span class="si">{</span><span class="n">centroid_b</span><span class="si">}</span><span class="s2">, count: </span><span class="si">{</span><span class="n">nodes_b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># print(f&quot;Centroid A: {centroid_a}, Umatrix value: {heat_a}&quot;, flush=True)</span>
            <span class="c1"># print(f&quot;Centroid B: {centroid_b}, Umatrix value: {heat_b}&quot;, flush=True)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merging...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">replace_a_with_b</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># this method takes the centroid with the larger number of nodes</span>
            <span class="k">if</span> <span class="n">nodes_a</span> <span class="o">&lt;</span> <span class="n">nodes_b</span><span class="p">:</span>
                <span class="n">replace_a_with_b</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># this method takes the centroid with the smaller U-matrix value</span>
            <span class="c1"># if heat_a &gt; heat_b:</span>
            <span class="c1">#     replace_a_with_b = True</span>

            <span class="k">if</span> <span class="n">replace_a_with_b</span><span class="p">:</span>
                <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_value</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">centroid_a</span><span class="p">,</span> <span class="n">centroid_b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace_value</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">centroid_b</span><span class="p">,</span> <span class="n">centroid_a</span><span class="p">)</span>

            <span class="c1"># print(&quot;New centroids: \n&quot;, centroids, flush=True)</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_similar_centroids</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unique_centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_centroids</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
            <span class="c1"># print(&quot;Centroids: \n&quot;, unique_centroids, flush=True)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Number of unique centroids: &quot;</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">]),</span>
                <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum cost between centroids: &quot;</span><span class="p">,</span> <span class="n">sorted_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">centroids</span>

        <span class="k">return</span> <span class="n">centroids</span></div>


<div class="viewcode-block" id="Lattice.get_unique_centroids">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.get_unique_centroids">[docs]</a>
    <span class="k">def</span> <span class="nf">get_unique_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out a list of unique centroids given a matrix of centroid locations.</span>

<span class="sd">        Args:</span>
<span class="sd">                centroids: A matrix of the centroid locations in the map.</span>

<span class="sd">        Returns:</span>
<span class="sd">                A dictionary containing the unique x and y positions of the centroids.</span>
<span class="sd">                The dictionary has the following keys:</span>
<span class="sd">                position_x: A list of unique x positions.</span>
<span class="sd">                position_y: A list of unique y positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the dimensions of the map</span>
        <span class="n">xdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
        <span class="n">ydim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span>
        <span class="n">xlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ylist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">centr_locs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># create a list of unique centroid positions</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xdim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ydim</span><span class="p">):</span>
                <span class="n">cx</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                <span class="n">cy</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_y&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>

                <span class="n">centr_locs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_count</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">centr_locs</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">centr_locs</span><span class="p">}</span>

        <span class="n">unique_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">centr_locs</span><span class="p">))</span>
        <span class="n">xlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">unique_ids</span><span class="p">]</span>
        <span class="n">ylist</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">unique_ids</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;position_x&quot;</span><span class="p">:</span> <span class="n">xlist</span><span class="p">,</span> <span class="s2">&quot;position_y&quot;</span><span class="p">:</span> <span class="n">ylist</span><span class="p">}</span></div>


<div class="viewcode-block" id="Lattice.compute_umat">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.compute_umat">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_umat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the unified distance matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">                smoothing (float, optional): A positive floating point value controlling the smoothing of the umat representation. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">                numpy.ndarray: A matrix with the same x-y dimensions as the original map containing the umat values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xdim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span><span class="p">)</span>
        <span class="n">umat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_heat</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">smoothing</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">umat</span></div>


<div class="viewcode-block" id="Lattice.compute_heat">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.compute_heat">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_heat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a heat value map representation of the given distance matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">                d (numpy.ndarray): A distance matrix computed via the &#39;dist&#39; function.</span>
<span class="sd">                smoothing (float, optional): A positive floating point value controlling the smoothing of the umat representation. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">                numpy.ndarray: A matrix with the same x-y dimensions as the original map containing the heat.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span>
        <span class="n">heat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span>
                <span class="s2">&quot;compute_heat: heat map can not be computed for a map </span><span class="se">\</span>
<span class="s2">	                 with a dimension of 1&quot;</span>
            <span class="p">)</span>

        <span class="c1"># this function translates our 2-dim lattice coordinates</span>
        <span class="c1"># into the 1-dim coordinates of the lattice</span>
        <span class="k">def</span> <span class="nf">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">):</span>

            <span class="k">return</span> <span class="n">ix</span> <span class="o">+</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">x</span>

        <span class="c1"># check if the map is larger than 2 x 2 (otherwise it is only corners)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># iterate over the inner nodes and compute their umat values</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                        <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                    <span class="p">)</span>

                    <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">8</span>

            <span class="c1"># iterate over bottom x axis</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">iy</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                <span class="p">)</span>

                <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">5</span>

            <span class="c1"># iterate over top x axis</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">iy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                <span class="p">)</span>

                <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">5</span>

            <span class="c1"># iterate over the left y-axis</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="p">)</span>

                <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">5</span>

            <span class="c1"># iterate over the right y-axis</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                <span class="p">)</span>

                <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">5</span>

        <span class="c1"># compute umat values for corners</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># bottom left corner</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
                <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="p">)</span>

            <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">3</span>

            <span class="c1"># bottom right corner</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">3</span>

            <span class="c1"># top left corner</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">3</span>

            <span class="c1"># top right corner</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">xl</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">),</span> <span class="n">xl</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="n">heat</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="n">smoothing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smoothing</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">heat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_2d</span><span class="p">(</span><span class="n">heat</span><span class="p">,</span> <span class="n">nrow</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">smoothing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">heat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_2d</span><span class="p">(</span>
                    <span class="n">heat</span><span class="p">,</span> <span class="n">nrow</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">smoothing</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;compute_heat: bad value for smoothing parameter&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">heat</span></div>


<div class="viewcode-block" id="Lattice.list_clusters">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.list_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">list_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">unique_centroids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the clusters as a list of lists., not very useful</span>

<span class="sd">        Args:</span>
<span class="sd">                centroids (matrix): A matrix of the centroid locations in the map.</span>
<span class="sd">                unique_centroids (list): A list of unique centroid locations.</span>

<span class="sd">        Returns:</span>
<span class="sd">                list: A list of clusters associated with each unique centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">centroids_x_positions</span> <span class="o">=</span> <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">]</span>
        <span class="n">centroids_y_positions</span> <span class="o">=</span> <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_y&quot;</span><span class="p">]</span>
        <span class="n">cluster_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids_x_positions</span><span class="p">)):</span>
            <span class="n">cx</span> <span class="o">=</span> <span class="n">centroids_x_positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cy</span> <span class="o">=</span> <span class="n">centroids_y_positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># get the clusters associated with a unique centroid and store it in a list</span>
            <span class="n">cluster_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_from_centroid</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">centroids</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cluster_list</span></div>


<div class="viewcode-block" id="Lattice.list_from_centroid">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.list_from_centroid">[docs]</a>
    <span class="k">def</span> <span class="nf">list_from_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">centroids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all cluster elements associated with one centroid.</span>

<span class="sd">        Args:</span>
<span class="sd">                x (int): The x position of a centroid.</span>
<span class="sd">                y (int): The y position of a centroid.</span>
<span class="sd">                centroids (numpy.ndarray): A matrix of the centroid locations in the map.</span>

<span class="sd">        Returns:</span>
<span class="sd">                list: A list of cluster elements associated with the given centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">centroid_x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">centroid_y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">xdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
        <span class="n">ydim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span>

        <span class="n">cluster_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xdim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ydim</span><span class="p">):</span>
                <span class="n">cx</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">][</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">]</span>
                <span class="n">cy</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_y&quot;</span><span class="p">][</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">]</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">cx</span> <span class="o">==</span> <span class="n">centroid_x</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cy</span> <span class="o">==</span> <span class="n">centroid_y</span><span class="p">):</span>
                    <span class="n">cweight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umat</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">]</span>
                    <span class="n">cluster_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cweight</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cluster_list</span></div>


<div class="viewcode-block" id="Lattice.smooth_2d">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.smooth_2d">[docs]</a>
    <span class="k">def</span> <span class="nf">smooth_2d</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Y</span><span class="p">,</span>
        <span class="n">ind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weight_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nrow</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
        <span class="n">ncol</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
        <span class="n">surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooths 2D data using a kernel smoother., internal function, no user-facing aspect</span>

<span class="sd">        Args:</span>
<span class="sd">                Y (array-like): The input data to be smoothed.</span>
<span class="sd">                ind (array-like, optional): The indices of the data to be smoothed. Defaults to None.</span>
<span class="sd">                weight_obj (dict, optional): The weight object used for smoothing. Defaults to None.</span>
<span class="sd">                grid (dict, optional): The grid object used for smoothing. Defaults to None.</span>
<span class="sd">                nrow (int, optional): The number of rows in the grid. Defaults to 64.</span>
<span class="sd">                ncol (int, optional): The number of columns in the grid. Defaults to 64.</span>
<span class="sd">                surface (bool, optional): Flag indicating whether the data represents a surface. Defaults to True.</span>
<span class="sd">                theta (float, optional): The theta value used in the exponential covariance function. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">                array-like: The smoothed data.</span>

<span class="sd">        Raises:</span>
<span class="sd">                None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">exp_cov</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">distMat</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">distMat</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
            <span class="n">distMat</span> <span class="o">=</span> <span class="n">distMat</span><span class="o">**</span><span class="n">p</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">distMat</span><span class="p">)</span>

        <span class="n">NN</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ncol</span><span class="p">]</span> <span class="o">*</span> <span class="n">nrow</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow</span><span class="p">)],</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">)]}</span>

        <span class="k">if</span> <span class="n">weight_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">grid</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">])</span>
            <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span>
            <span class="n">xg</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                    <span class="n">xg</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]])</span>

            <span class="n">xg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xg</span><span class="p">)</span>

            <span class="n">center</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">center</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">M</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">((</span><span class="n">dy</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">exp_cov</span><span class="p">(</span><span class="n">xg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">),</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)))</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
            <span class="n">temp</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">M</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)][</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">wght</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>
            <span class="n">weight_obj</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="n">N</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="n">M</span><span class="p">,</span> <span class="s2">&quot;wght&quot;</span><span class="p">:</span> <span class="n">wght</span><span class="p">}</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]))</span>
        <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y</span>
        <span class="n">temp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;wght&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">real</span><span class="p">[</span>
            <span class="mi">0</span> <span class="p">:</span> <span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">],</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]))</span>
        <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">NN</span>
        <span class="n">temp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;wght&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">real</span><span class="p">[</span>
            <span class="mi">0</span> <span class="p">:</span> <span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">],</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">weight_obj</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">temp2</span> <span class="o">/</span> <span class="n">temp3</span></div>


<div class="viewcode-block" id="Lattice.plot_heat">
<a class="viewcode-back" href="../../aweSOM.html#aweSOM.som.Lattice.plot_heat">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_heat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heat</span><span class="p">,</span> <span class="n">explicit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">merge_cost</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the heat map of the given data.</span>

<span class="sd">        Args:</span>
<span class="sd">                heat (array-like): The data to be plotted.</span>
<span class="sd">                explicit (bool, optional): A flag indicating whether the connected components are explicit. Defaults to False.</span>
<span class="sd">                comp (bool, optional): A flag indicating whether to plot the connected components. Defaults to True.</span>
<span class="sd">                merge (bool, optional): A flag indicating whether to merge the connected components. Defaults to False.</span>
<span class="sd">                merge_cost (float, optional): The threshold for merging the connected components. Defaults to 0.001.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydim</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

        <span class="c1"># need to make sure the map doesn&#39;t have a dimension of 1</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;plot_heat: map dimensions too small&quot;</span><span class="p">)</span>

        <span class="n">heat_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">heat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># Convert 2D Array to 1D</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span>
            <span class="n">heat_tmp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">heat_tmp</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">heat_tmp</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>  <span class="c1"># Convert 1D Array to 2D</span>

        <span class="n">tmp_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;font.size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolor</span><span class="p">(</span><span class="n">tmp_1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">YlOrRd</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">minor</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">minor</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">minor</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">labeltop</span><span class="o">=</span><span class="s2">&quot;on&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">labelright</span><span class="o">=</span><span class="s2">&quot;on&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># put the connected component lines on the map</span>
        <span class="k">if</span> <span class="n">comp</span><span class="p">:</span>

            <span class="c1"># find the centroid for each node on the map</span>
            <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_centroids</span><span class="p">(</span><span class="n">explicit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">merge</span><span class="p">:</span>
                <span class="c1"># find the unique centroids for the nodes on the map</span>
                <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_similar_centroids</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">merge_cost</span><span class="p">)</span>

            <span class="n">unique_centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_centroids</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unique centroids : &quot;</span><span class="p">,</span> <span class="n">unique_centroids</span><span class="p">)</span>

            <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_y&quot;</span><span class="p">]</span>
            <span class="p">]</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_x&quot;</span><span class="p">],</span>
                <span class="n">unique_centroids</span><span class="p">[</span><span class="s2">&quot;position_y&quot;</span><span class="p">],</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># connect each node to its centroid</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">cx</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">cy</span> <span class="o">=</span> <span class="n">centroids</span><span class="p">[</span><span class="s2">&quot;centroid_y&quot;</span><span class="p">][</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">cx</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">iy</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">],</span>
                        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span>
                        <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="c1"># put the labels on the map if available</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_data_to_lattice</span><span class="p">()</span>  <span class="c1"># obtain the projection_1d array</span>

            <span class="c1"># count the labels in each map cell</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span><span class="p">):</span>

                <span class="n">nix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_1d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nix</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
                <span class="p">)</span>  <span class="c1"># NOTE: slow code</span>
                <span class="c1"># print(c)</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

                <span class="n">count</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span><span class="p">):</span>

                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection_1d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xdim</span>
                <span class="p">)</span>  <span class="c1"># NOTE: slow code</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">iy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># we only print one label per cell</span>
                <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="n">count</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="mf">0.5</span>
                    <span class="n">iy</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">-</span> <span class="mf">0.5</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Trung Ha.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>